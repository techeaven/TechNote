---
title: MySQL优化小结
categories: B-MySQL优化
permalink: sumary-of-mysql-optimization
translate_title: summary-of-mysql-optimization
date: 2015-07-27 03:09:10
tags:
description:
---
## 概述
MySQL优化是一个庞大的命题，可以优化的方面有很多，比如主从、读写分离、SQL语句优化等。这篇文章简单做个小结，随时补充。

## 表字段数据类型
### 能小就用小
表数据类型第一个原则是：使用能正确的表示和存储数据的最短类型。这样可以减少对磁盘空间、内存、cpu缓存的使用。
### 避免用NULL
这是MySQL优化经常提到的内容。理由是额外增加字节，还有使索引，索引统计和值更复杂。还有很重要的一点是count(列)的问题，count(列)是不会统计列值为null的行数。
### char和varchar
提到char和varchar，第一反应就是char是固定大小，varchar是变长的。  

两者都能存储长度为255的字符，并且会忽略掉字符编码。MySQL **5.0.3**之后的版本中，varchar可以存储65535长度的字符。超过可存储的长度后，MySQL会自动截取字符串，并且无报错。  

char比varchat快50%左右。
### 整型优先原则
tinyint、smallint、mediumint、int、bigint，分别需要8、16、24、32、64。  

**能用tinyint的绝不用smallint**。  

**能用整形的不用其他类型替换，如ip可以转换成整形保存**
### 精确度
在存储相同数值范围的数据时，浮点数类型通常都会比DECIMAL类型使用更少的空间。FLOAT字段使用4字节存储数据。DOUBLE类型需要8个字节并拥有更高的精确度和更大的数值范围，DECIMAL类型的数据将会转换成DOUBLE类型。

## SQL语句优化
SQL语句优化的重点个人觉得是索引的使用。索引的使用遵循**最左前缀原则**，该原则一般是指复合索引(多列索引)。  

最左前缀原则定义：最左前缀原则指的的是在where子句中一些条件或表达式中出现的列的顺序要保持和多索引的一致或以多列索引顺序出现，只要出现**非顺序**出现、**断层**都无法利用到多列索引。  

> 最左前缀原则中where字句有or出现还是会遍历全表

### 正确的利用索引
如复合索引`index(id, username, password)`，只有一下where表达式满足以下三种情况才能正确利用索引：
* id
* id, username
* id, username, password

相反的，以下几种情况都不能正确的利用索引：
* username, password (断层)
* password (断层)
* id>N, username, password (非第一列出现范围,则能利用索引到首先出现范围的一列, 所以多列索引的时候把那些查询语句用的比较的列放在最后或非第一位)
* id, password (断层)

### 补洞
如果一个查询where子句中确实不需要某列，那就用“补洞”。  

### like
对like语句的优化也很重要，在like查询中，也有几种情况：
* like 'aa%'  可以利用索引
* like '%aa'  不能利用索引
* like '%aa%' 不能利用索引

### order by优化
在mysql version()<4.1之前，优化器采用的是filesort第一种优化算法，先提取键值和指针，排序后再去提取数据，前后要搜索数据两次，第一次若能使用索引则使用，第二次是随机读(当然不同引擎也不同)。mysql version()>=4.1,更新了一个新算法，就是在第一次读的时候也把selcet的列也读出来，然后在**sort_buffer_size**中排序(不够大则建临时表保存排序顺序)，这算法只需要一次读取数据。所以有这个广为人传的一个优化方法，那就是增大sort_buffer_size。Filesort第二种算法要用到更的空间，sort_buffer_size不够大反而会影响速度，所以mysql开发团队定了个变量**max_length_for_sort_data**，当算法中读出来的需要列的数据的大小超过该变量的值才使用，所以一般性能分析的时候会尝试把max_length_for_sort_data改小。

单独order by 用不了索引，索引考虑加where 或加limit。  

where + orerby 类型，where满足最左前缀原则，且orderby的列和where子句用到的索引的列的子集。即是(a,b,c)索引，where满足最左前缀原则且order by中列a、b、c的任意组合。  

在比较常用的oder by的列和where中常用的列建立多列索引，这样优化起来的广度和扩张性都比较好，如果要考虑UNION、JOIN、COUNT、IN等进来就复杂很多了。  

### 隔离列
隔离列是指在查询语句中把索引列隔离出来，也就是说不能在语句中把索引列包含进表达式中，如id+1=2、inet_aton(’210.38.196.138′)—ip转换成整数、convert(123,char(3))—数字转换成字符串、date函数等mysql内置的大多函数。  

非隔离列影响性能很大甚至是致命的，这也就是赶集网石展的《三十六军规》中的一条，虽然他没说明是隔离列。

### or
or会遍历表就算有索引

### in
对于in，这个是有争议的，网上很多优化方案中都提到尽量少用in，这不全面，其实在in里面如果是常量的话，可以大胆的用in，这个也是赶集网石展、阿里hellodab的观点(笔者从微博中获知)。应用hellodab一句话“MySQL用IN效率不好，通常是指in中嵌套一个子查询，因为MySQL的查询重写可能会产生一个不好的执行计划，而如果in里面是常量的话，我认为性能没有任何问题，可以放心使用”———当然对于这个比较的话，没有实战数据的话很难辩解，就算有，影响性能的因素也很多，也许会每个dba都有不同的测试结果.这也签名最左前缀中“补洞”一个方法。  

### UNION All
UNION All 直接返回并集，可以避免去重的开销。之所说“尝试”用UNION All 替代 OR来优化sql语句，因为这不是一直能优化的了，这里只是作为一个方法去尝试。  

### 索引选择性
索引选择性是指不重复的索引值，也叫基数(cardinality)表中数据行数的比值，索引选择性=基数/数据行，基数可以通过“show index from 表名”查看。  

高索引选择性的好处就是mysql查找匹配的时候可以过滤更多的行，唯一索引的选择性最佳，值为1。

### 重复或多余索引
要防止出现索引过度的问题。要有个意识就是，在满足功能需求的情况下建最少索引。对于INNODB引擎的索引来说，每次修改数据都要把主键索引，辅助索引中相应索引值修改，这可能会出现大量数据迁移，分页，以及碎片的出现。

## 配置优化
### 变量相关
* key_buffer_size，索引块缓存区大小, 针对MyISAM存储引擎,该值越大,性能越好.但是超过操作系统能承受的最大值,反而会使mysql变得不稳定. —-这是很重要的参数
* sort_buffer_size 这是索引在排序缓冲区大小，若排序数据大小超过该值，则创建临时文件，注意和myisam_sort_buffer_size的区别—-这是很重要的参数
* read_rnd_buffer_size当排序后按排序后的顺序读取行时，则通过该缓冲区读取行，避免搜索硬盘。将该变量设置为较大的值可以大大改进ORDER BY的性能。但是，这是为每个客户端分配的缓冲区，因此你不应将全局变量设置为较大的值。相反，只为需要运行大查询的客户端更改会话变量
* join_buffer_size用于表间关联(join)的缓存大小
* tmp_table_size缓存表的大小
* table_cache允许 MySQL 打开的表的最大个数，并且这些都cache在内存中
* delay_key_write针对MyISAM存储引擎,延迟更新索引.意思是说,update记录时,先将数据up到磁盘,但不up索引,将索引存在内存里,当表关闭时,将内存索引,写到磁盘

### 数据表维护操作
1.optimize  

数据在插入，更新，删除的时候难免一些数据迁移，分页，之后就出现一些碎片，久而久之碎片积累起来影响性能，这就需要DBA定期的优化数据库减少碎片，这就通过optimize命令。  

如对MyisAM表操作：optimize table 表名  

对于InnoDB表是不支持optimize操作，否则提示“Table does not support optimize, doing recreate + analyze instead”，当然也可以通过命令：alter table one type=innodb; 来替代。  

2.Analyze  

用来分析和存储表的关键字的分布，使得系统获得准确的统计信息，影响 SQL 的执行计划的生成。对于数据基本没有发生变化的表，是不需要经常进行表分析的。但是如果表的数据量变化很明显，用户感觉实际的执行计划和预期的执行计划不 同的时候，执行一次表分析可能有助于产生预期的执行计划。  

Analyze table 表名

3.Check  

检查表或者视图是否存在错误，对 MyISAM 和 InnoDB 存储引擎的表有作用。对于 MyISAM 存储引擎的表进行表检查，也会同时更新关键字统计数据  

4.Repair  

optimize需要有足够的硬盘空间，否则可能会破坏表，导致不能操作，那就要用上repair，注意INNODB不支持repair操作

### 表结构更新与维护
1.改表结构  

当要在数据量千万级的数据表中使用alter更改表结构的时候，这是一个棘手问题。一种方法是在低并发低访问量的时候用平常的alter更改表。另外一种就是建另一个与要修改的表，这个表除了要修改的结构属性外其他的和原表一模一样，这样就能得到一个相应的.frm文件，然后用flush with read lock 锁定读，然后覆盖用新建的.frm文件覆盖原表的.frm，最后unlock table 释放表。  

2.建立新的索引
*  创建没索引的a表，导入数据形成.MYD文件。
*  创建包括索引b表，形成.FRM和.MYI文件
*  锁定读写
*  把b表的.FRM和.MYI文件改成a表名字
*  解锁
*  用repair创建索引

### 定期检查mysql服务器
定期使用show status、show processlist等命令检查数据库。

## mysql查询执行流程
![](https://github.com/tudouya/blogSource/blob/master/images/aa213e02jw1esgahxa4zyj20lb0j1jun.jpg?raw=true)

* 查询缓存，判断sql语句是否完全匹配，再判断是否有权限，两个判断为假则到解析器解析语句，为真则提取数据结果返回给用户。
* 解析器解析，解析器先词法分析，语法分析，检查错误比如引号有没闭合等，然后生成解析树。
* 预处理。预处理解决解析器无法决解的语义，如检查表和列是否存在，别名是否有错，生成新的解析树。
* 优化器做大量的优化操作。
* 生成执行计划。
* 查询执行引擎，负责调度引擎获取相应数据
* 返回结果。


## 参考
* [由浅入深探究 MySQL索引结构原理、性能分析与优化](http://blog.jobbole.com/87107/)
<br />
